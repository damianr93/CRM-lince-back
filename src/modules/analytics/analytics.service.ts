import { Inject, Injectable, InternalServerErrorException } from '@nestjs/common';
import { CreateAnalyticsDto } from './dto/create-analytics.dto';
import { UpdateAnalyticsDto } from './dto/update-analytics.dto';
import mongoose, { Model } from 'mongoose';
import { Client } from '../customer/schema/customer.schema';
import { ChannelData, ProductData, TimePoint } from './interface/analytics.interface';
import { FollowUpEventsService } from '../customer/follow-up/follow-up-events.service';
import { GeoService } from '../geo/geo.service';
import {
  FollowUpEventStatus,
} from '../customer/follow-up/follow-up-event.schema';
import { MessageChannelType } from '../customer/follow-up/follow-up.types';
import PDFDocument = require('pdfkit');
import type * as PDFKit from 'pdfkit';

type FollowUpEventView = {
  id: string;
  customerName?: string;
  customerLastName?: string;
  assignedTo?: string;
  customerPhone?: string;
  product?: string;
  triggerStatus: string;
  templateId: string;
  message: string;
  channels: MessageChannelType[];
  contactValue?: string | null;
  scheduledFor: string;
  status: FollowUpEventStatus;
  readyAt?: string | null;
  createdAt: string;
  completedAt?: string | null;
  notes?: string | null;
};

type LocationFilters = {
  startDate?: string;
  endDate?: string;
  provincias?: string[];
  paises?: string[];
  zonas?: string[];
};

type LocationSummary = {
  total: number;
  noLocation: { total: number; percentage: number };
  topProvinces: Array<{ name: string; total: number; percentage: number }>;
  topLocalities: Array<{ name: string; province: string; total: number; percentage: number }>;
  mapPoints: Array<{ name: string; lat: number; lon: number; total: number }>;
};

type LocationHeatmap = {
  total: number;
  provinces: Array<{ name: string; normalized: string; total: number; percentage: number }>;
};

type LocationReport = {
  total: number;
  totalReconsultas: number;
  noLocation: { total: number; percentage: number; reconsultas: number };
  countries: Array<{
    name: string;
    total: number;
    percentage: number;
    provinces: Array<{
      name: string;
      total: number;
      percentage: number;
      topProduct?: { name: string; total: number; percentage: number };
      reconsultas: number;
      topLocalities: Array<{ name: string; total: number; percentage: number }>;
      localities: Array<{
        name: string;
        total: number;
        percentage: number;
        topProduct?: { name: string; total: number; percentage: number };
        reconsultas: number;
      }>;
    }>;
  }>;
};

@Injectable()
export class AnalyticsService {
  private readonly normalizationBatchSize = 80;
  private readonly normalizationConcurrency = 2;
  private readonly normalizationMaxBatches = 10;
  private readonly geoFailureCache = new Map<string, number>();
  private readonly geoFailureTtlMs = 1000 * 60 * 60 * 12;

  constructor(
    @Inject('CLIENT_MODEL')
    private readonly clientModel: Model<Client>,
    private readonly followUpEventsService: FollowUpEventsService,
    private readonly geoService: GeoService,
  ) {}

  /**
   * Devuelve:
   *  - totalContacts: numero total de documentos en la coleccion clients
   *  - totalReconsultas: cantidad de registros marcados como reconsulta
   *  - firstTimeContacts: contactos unicos sin reconsulta
   *  - byChannel: arreglo de { channel, total }, agrupado por medioAdquisicion
   */
  async totales(): Promise<{
    totalContacts: number;
    totalReconsultas: number;
    firstTimeContacts: number;
    byChannel: ChannelData[];
  }> {
    try {
      const [totalContacts, totalReconsultas, aggregation] = await Promise.all([
        this.clientModel.countDocuments().exec(),
        this.clientModel.countDocuments({ isReconsulta: true }).exec(),
        this.clientModel
          .aggregate([
            {
              $group: {
                _id: '$medioAdquisicion',
                count: { $sum: 1 },
              },
            },
            {
              $sort: { count: -1 }, // opcional: ordenar de mayor a menor
            },
          ])
          .exec(),
      ]);

      const firstTimeContacts = Math.max(totalContacts - totalReconsultas, 0);

      const byChannel: ChannelData[] = aggregation.map((entry) => ({
        channel: entry._id || 'OTRO',
        total: entry.count,
      }));

      return { totalContacts, totalReconsultas, firstTimeContacts, byChannel };
    } catch (err) {
      console.error('Error en AnalyticsService.totales:', err);
      throw new InternalServerErrorException('Error al obtener totales de clientes');
    }
  }

  /**
   * Retorna un arreglo de { date: "YYYY-MM", total }, 
   * contando cuÃ¡ntos clientes se crearon en cada mes de 2025.
   */
  async evolution(): Promise<TimePoint[]> {
    try {
      // Podemos parametrizar el rango, pero de momento fija 2025.
      const startOfYear = new Date('2025-01-01T00:00:00.000Z');
      const endOfYear = new Date('2025-12-31T23:59:59.999Z');

      const pipeline: mongoose.PipelineStage[] = [
        {
          $match: {
            createdAt: {
              $gte: startOfYear,
              $lt: endOfYear,
            },
          },
        },
        {
          $group: {
            _id: {
              year: { $year: '$createdAt' },
              month: { $month: '$createdAt' },
            },
            count: { $sum: 1 },
          },
        },
        {
          $sort: { '_id.year': 1, '_id.month': 1 },
        },
        {
          $project: {
            _id: 0,
            date: {
              $concat: [
                { $toString: '$_id.year' },
                '-',
                {
                  $cond: [
                    { $lt: ['$_id.month', 10] },
                    { $concat: ['0', { $toString: '$_id.month' }] },
                    { $toString: '$_id.month' },
                  ],
                },
              ],
            },
            total: '$count',
          },
        },
      ];

      const result: Array<{ date: string; total: number }> = await this.clientModel
        .aggregate(pipeline)
        .exec();

      // Si quisieras asegurar que haya entrada para cada mes (incluso con total=0), podrÃ­as
      // post-procesar aquÃ­. Dejo la versiÃ³n bÃ¡sica.
      return result.map((item) => ({
        date: item.date,
        total: item.total,
      }));
    } catch (err) {
      console.error('Error en AnalyticsService.evolution:', err);
      throw new InternalServerErrorException('Error al obtener evoluciÃ³n de clientes');
    }
  }

  /**
   * Retorna un arreglo de los productos mÃ¡s consultados/comprados:
   *  { product, total } ordenado de mayor a menor en base a la cuenta de clientes asociados a cada producto.
   */
  async demandOfProduct(): Promise<ProductData[]> {
    try {
      const aggregation: Array<{ _id: string; count: number }> = await this.clientModel
        .aggregate([
          {
            $group: {
              _id: '$producto',
              count: { $sum: 1 },
            },
          },
          {
            $sort: { count: -1 },
          },
          {
            $limit: 10, // opcional: solo top 10
          },
        ])
        .exec();

      const result: ProductData[] = aggregation.map((entry) => ({
        product: entry._id || 'Desconocido',
        total: entry.count,
      }));

      return result;
    } catch (err) {
      console.error('Error en AnalyticsService.demandOfProduct:', err);
      throw new InternalServerErrorException('Error al obtener demanda de productos');
    }
  }

  async purchaseStatus(): Promise<{ status: string; total: number; percentage: number }[]> {
  try {
    const aggregation: Array<{ _id: string; count: number }> = await this.clientModel
      .aggregate([
        {
          $group: {
            _id: '$estado',
            count: { $sum: 1 },
          },
        },
        {
          $sort: { count: -1 },
        },
      ])
      .exec();

    const totalClients = await this.clientModel.countDocuments().exec();

    const statusMap = {
      'COMPRO': 'Compras',
      'NO_COMPRO': 'No Compras', 
      'PENDIENTE': 'Pendientes',
    };

    const statusCount = {
      'Compras': 0,
      'No Compras': 0,
      'Pendientes': 0,
    };

    aggregation.forEach((entry) => {
      const normalizedStatus = statusMap[entry._id] || 'Pendientes';
      statusCount[normalizedStatus] += entry.count;
    });

    const result = Object.entries(statusCount).map(([status, total]) => ({
      status,
      total,
      percentage: totalClients > 0 ? Math.round((total / totalClients) * 100) : 0,
    }));

    return result;
  } catch (err) {
    console.error('Error en AnalyticsService.purchaseStatus:', err);
    throw new InternalServerErrorException('Error al obtener estado de compras');
  }
}

  async followUpEvents(assignedTo?: string, statusesParam?: string): Promise<FollowUpEventView[]> {
    try {
      let statuses: FollowUpEventStatus[] = ['READY'];

      if (statusesParam) {
        const parsed = statusesParam
          .split(',')
          .map((status) => status.trim().toUpperCase())
          .filter((status): status is FollowUpEventStatus =>
            ['READY', 'COMPLETED', 'CANCELLED', 'SCHEDULED'].includes(status),
          );

        if (parsed.length > 0) {
          statuses = parsed;
        }
      }

      const events = await this.followUpEventsService.getEventsByStatus(
        statuses,
        100,
        assignedTo,
      );

      return events.map((event) => ({
        id: event._id.toString(),
        customerName: event.customerName,
        customerLastName: event.customerLastName,
        assignedTo: event.assignedTo,
        customerPhone: event.customerPhone,
        product: event.product,
        triggerStatus: event.triggerStatus,
        templateId: event.templateId,
        message: event.message,
        channels: event.channels as MessageChannelType[],
        contactValue: event.contactValue ?? null,
        scheduledFor: new Date(event.scheduledFor).toISOString(),
        status: event.status as FollowUpEventStatus,
        readyAt: event.readyAt ? new Date(event.readyAt).toISOString() : null,
        createdAt: event.createdAt
          ? new Date(event.createdAt).toISOString()
          : new Date(event.scheduledFor).toISOString(),
        completedAt: event.completedAt ? new Date(event.completedAt).toISOString() : null,
        notes: event.notes ?? null,
      }));
    } catch (err) {
      console.error('Error en AnalyticsService.followUpEvents:', err);
      throw new InternalServerErrorException('Error al obtener eventos de seguimiento');
    }
  }

  async locationSummary(filters: LocationFilters): Promise<LocationSummary> {
    try {
      await this.ensureNormalizedLocations(filters);
      const report = await this.buildLocationReport(filters);
      const total = report.total;
      const topProvinceMap = new Map<
        string,
        { name: string; total: number; percentage: number }
      >();
      report.countries.forEach((country) => {
        country.provinces.forEach((province) => {
          const normalized = this.normalizeProvinceKey(province.name);
          if (!normalized || normalized.startsWith('sin ')) {
            return;
          }
          const existing = topProvinceMap.get(normalized);
          if (existing) {
            existing.total += province.total;
            existing.percentage = total > 0 ? Math.round((existing.total / total) * 100) : 0;
            if (province.name.length > existing.name.length) {
              existing.name = province.name;
            }
          } else {
            topProvinceMap.set(normalized, {
              name: province.name,
              total: province.total,
              percentage: total > 0 ? Math.round((province.total / total) * 100) : 0,
            });
          }
        });
      });

      const topProvinces = Array.from(topProvinceMap.values())
        .sort((a, b) => b.total - a.total)
        .slice(0, 6);

      const topLocalities = report.countries
        .flatMap((country) =>
          country.provinces.flatMap((province) =>
            province.localities.map((locality) => ({
              name: locality.name,
              province: province.name,
              total: locality.total,
              percentage: total > 0 ? Math.round((locality.total / total) * 100) : 0,
            })),
          ),
        )
        .sort((a, b) => b.total - a.total)
        .slice(0, 6);

      const mapPoints = await this.getMapPoints(report, filters);

      return {
        total,
        noLocation: report.noLocation,
        topProvinces,
        topLocalities,
        mapPoints,
      };
    } catch (err) {
      console.error('Error en AnalyticsService.locationSummary:', err);
      throw new InternalServerErrorException('Error al obtener resumen de ubicaciones');
    }
  }

  async locationHeatmap(filters: LocationFilters): Promise<LocationHeatmap> {
    try {
      await this.ensureNormalizedLocations(filters);
      const report = await this.buildLocationReport(filters);
      const provinces = this.buildHeatmapProvinces(report);
      return { total: report.total, provinces };
    } catch (err) {
      console.error('Error en AnalyticsService.locationHeatmap:', err);
      throw new InternalServerErrorException('Error al obtener mapa de calor');
    }
  }

  async locationReportPdf(filters: LocationFilters): Promise<Buffer> {
    await this.ensureNormalizedLocations(filters);
    const report = await this.buildLocationReport(filters);
    const clients = await this.findClientsForReport(filters);
    return this.generateLocationPdf(report, clients, filters);
  }

  async locationDebug(filters: LocationFilters) {
    const report = await this.buildLocationReport(filters);
    const mapPoints = await this.getMapPoints(report, filters);
    const provinces = report.countries.flatMap((country) =>
      country.provinces.map((province) => ({
        name: province.name,
        total: province.total,
      })),
    );
    return {
      reportTotal: report.total,
      noLocation: report.noLocation,
      topProvinces: provinces.slice(0, 10),
      mapPoints,
    };
  }

  async locationMapImage(
    filters: LocationFilters,
  ): Promise<{ buffer: Buffer; contentType: string } | null> {
    try {
      const report = await this.buildLocationReport(filters);
      const points = await this.getMapPoints(report, filters);
      const defaultCenter = { lat: -38.4161, lon: -63.6167 };
      const center = points[0] ?? defaultCenter;
      const markers = points.length
        ? points
            .slice(0, 8)
            .map((point) => `${point.lat},${point.lon},lightblue1`)
            .join('|')
        : '';
      const markerParam = markers ? `&markers=${encodeURIComponent(markers)}` : '';
      const url = `https://staticmap.openstreetmap.de/staticmap.php?center=${center.lat},${center.lon}&zoom=4&size=800x440&maptype=mapnik${markerParam}`;
      const response = await fetch(url);
      if (response.ok) {
        const arrayBuffer = await response.arrayBuffer();
        return { buffer: Buffer.from(arrayBuffer), contentType: 'image/png' };
      }

      const svg = this.buildSvgMap(points, center);
      return { buffer: Buffer.from(svg), contentType: 'image/svg+xml' };
    } catch (error) {
      const fallbackCenter = { lat: -38.4161, lon: -63.6167 };
      const svg = this.buildSvgMap([], fallbackCenter);
      return { buffer: Buffer.from(svg), contentType: 'image/svg+xml' };
    }
  }

  private buildSvgMap(
    points: LocationSummary['mapPoints'],
    center: { lat: number; lon: number },
  ): string {
    const width = 800;
    const height = 440;
    const latMin = -55;
    const latMax = -22;
    const lonMin = -73;
    const lonMax = -53;
    const project = (lat: number, lon: number) => {
      const x = ((lon - lonMin) / (lonMax - lonMin)) * width;
      const y = height - ((lat - latMin) / (latMax - latMin)) * height;
      return { x, y };
    };
    const maxTotal = Math.max(...points.map((p) => p.total), 1);
    const circles = points
      .map((point) => {
        const { x, y } = project(point.lat, point.lon);
        const radius = 4 + Math.round((point.total / maxTotal) * 8);
        return `<circle cx="${x.toFixed(1)}" cy="${y.toFixed(
          1,
        )}" r="${radius}" fill="#38BDF8" stroke="#0F172A" stroke-width="1" />`;
      })
      .join('');

    const centerPoint = project(center.lat, center.lon);
    return `
      <svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
        <defs>
          <linearGradient id="bg" x1="0" x2="1" y1="0" y2="1">
            <stop offset="0%" stop-color="#0F172A"/>
            <stop offset="100%" stop-color="#111827"/>
          </linearGradient>
        </defs>
        <rect width="${width}" height="${height}" fill="url(#bg)" />
        <rect x="20" y="20" width="${width - 40}" height="${height - 40}" fill="#0B1220" stroke="#1F2937" stroke-width="2" rx="16" />
        <text x="40" y="60" fill="#FBBF24" font-size="16" font-family="Arial">Mapa de Consultas (Argentina)</text>
        <text x="40" y="85" fill="#94A3B8" font-size="11" font-family="Arial">Centros provinciales y puntos de demanda</text>
        ${circles}
        <circle cx="${centerPoint.x.toFixed(1)}" cy="${centerPoint.y.toFixed(1)}" r="4" fill="#FBBF24" />
      </svg>
    `;
  }

  private async buildLocationReport(filters: LocationFilters): Promise<LocationReport> {
    return this.buildLocationAggregations(filters);
  }

  private async buildLocationAggregations(filters: LocationFilters): Promise<LocationReport> {
    const matchDate: Record<string, any> = {};
    if (filters.startDate || filters.endDate) {
      matchDate.createdAt = {};
      if (filters.startDate) {
        matchDate.createdAt.$gte = new Date(filters.startDate);
      }
      if (filters.endDate) {
        matchDate.createdAt.$lte = new Date(filters.endDate);
      }
    }

    const invalidTokens = [
      '-',
      'null',
      'undefined',
      'sin datos',
      'sin informacion',
      'sin información',
      'no disponible',
      'n/a',
      'na',
      'sin localidad',
      'sin provincia',
      'sin pais',
      'sin país',
      'sin datos de ubicacion del cliente',
      'sin datos de ubicación del cliente',
    ];

    const buildCleanStringExpr = (path: string) => ({
      $let: {
        vars: {
          raw: { $ifNull: [path, ''] },
          trimmed: { $trim: { input: { $ifNull: [path, ''] } } },
          lower: { $toLower: { $trim: { input: { $ifNull: [path, ''] } } } },
        },
        in: {
          $cond: [
            {
              $or: [
                { $eq: ['$$trimmed', ''] },
                {
                  $regexMatch: {
                    input: '$$trimmed',
                    regex: '{{|}}|cuf_',
                    options: 'i',
                  },
                },
                { $in: ['$$lower', invalidTokens] },
              ],
            },
            null,
            '$$trimmed',
          ],
        },
      },
    });

    const normalizedLocationFlag = { $eq: ['$ubicacion.esNormalizada', true] };
    const resolvedProvince = {
      $cond: [normalizedLocationFlag, buildCleanStringExpr('$ubicacion.provincia'), null],
    };
    const resolvedLocality = {
      $cond: [normalizedLocationFlag, buildCleanStringExpr('$ubicacion.localidad'), null],
    };
    const resolvedCountry = { $literal: 'Argentina' };
    const resolvedZone = {
      $cond: [normalizedLocationFlag, buildCleanStringExpr('$ubicacion.zona'), null],
    };
    const resolvedProduct = {
      $ifNull: [buildCleanStringExpr('$producto'), 'Sin dato'],
    };

    const matchResolved: Record<string, any> = {};
    if (filters.provincias && filters.provincias.length > 0) {
      matchResolved.resolvedProvince = { $in: filters.provincias };
    }
    if (filters.paises && filters.paises.length > 0) {
      matchResolved.resolvedCountry = { $in: filters.paises };
    }
    if (filters.zonas && filters.zonas.length > 0) {
      matchResolved.resolvedZone = { $in: filters.zonas };
    }

    const pipeline: mongoose.PipelineStage[] = [
      Object.keys(matchDate).length > 0 ? { $match: matchDate } : { $match: {} },
      {
        $addFields: {
          resolvedProvince,
          resolvedLocality,
          resolvedCountry,
          resolvedZone,
          resolvedProduct,
        },
      },
      {
        $addFields: {
          hasLocation: {
            $or: [
              { $ne: ['$resolvedProvince', null] },
              { $ne: ['$resolvedLocality', null] },
              { $ne: ['$resolvedZone', null] },
            ],
          },
        },
      },
      Object.keys(matchResolved).length > 0 ? { $match: matchResolved } : { $match: {} },
      {
        $facet: {
          totals: [
            {
              $group: {
                _id: null,
                total: { $sum: 1 },
                reconsultas: {
                  $sum: { $cond: [{ $eq: ['$isReconsulta', true] }, 1, 0] },
                },
              },
            },
          ],
          noLocation: [
            { $match: { hasLocation: false } },
            {
              $group: {
                _id: null,
                total: { $sum: 1 },
                reconsultas: {
                  $sum: { $cond: [{ $eq: ['$isReconsulta', true] }, 1, 0] },
                },
              },
            },
          ],
          countries: [
            { $match: { hasLocation: true } },
            {
              $group: {
                _id: '$resolvedCountry',
                total: { $sum: 1 },
                reconsultas: {
                  $sum: { $cond: [{ $eq: ['$isReconsulta', true] }, 1, 0] },
                },
              },
            },
            { $sort: { total: -1 } },
          ],
          provinces: [
            { $match: { hasLocation: true } },
            {
              $group: {
                _id: {
                  country: '$resolvedCountry',
                  province: '$resolvedProvince',
                },
                total: { $sum: 1 },
                reconsultas: {
                  $sum: { $cond: [{ $eq: ['$isReconsulta', true] }, 1, 0] },
                },
              },
            },
            { $sort: { total: -1 } },
          ],
          localities: [
            { $match: { hasLocation: true } },
            {
              $group: {
                _id: {
                  country: '$resolvedCountry',
                  province: '$resolvedProvince',
                  locality: '$resolvedLocality',
                },
                total: { $sum: 1 },
                reconsultas: {
                  $sum: { $cond: [{ $eq: ['$isReconsulta', true] }, 1, 0] },
                },
              },
            },
            { $sort: { total: -1 } },
          ],
          topProductProvince: [
            { $match: { hasLocation: true } },
            {
              $group: {
                _id: {
                  country: '$resolvedCountry',
                  province: '$resolvedProvince',
                  product: '$resolvedProduct',
                },
                total: { $sum: 1 },
              },
            },
            { $sort: { total: -1 } },
            {
              $group: {
                _id: {
                  country: '$_id.country',
                  province: '$_id.province',
                },
                product: { $first: '$_id.product' },
                total: { $first: '$total' },
              },
            },
          ],
          topProductLocality: [
            { $match: { hasLocation: true } },
            {
              $group: {
                _id: {
                  country: '$resolvedCountry',
                  province: '$resolvedProvince',
                  locality: '$resolvedLocality',
                  product: '$resolvedProduct',
                },
                total: { $sum: 1 },
              },
            },
            { $sort: { total: -1 } },
            {
              $group: {
                _id: {
                  country: '$_id.country',
                  province: '$_id.province',
                  locality: '$_id.locality',
                },
                product: { $first: '$_id.product' },
                total: { $first: '$total' },
              },
            },
          ],
          topLocalitiesByProvince: [
            { $match: { hasLocation: true } },
            {
              $group: {
                _id: {
                  country: '$resolvedCountry',
                  province: '$resolvedProvince',
                  locality: '$resolvedLocality',
                },
                total: { $sum: 1 },
              },
            },
            { $sort: { total: -1 } },
            {
              $group: {
                _id: { country: '$_id.country', province: '$_id.province' },
                localities: {
                  $push: {
                    name: '$_id.locality',
                    total: '$total',
                  },
                },
              },
            },
            {
              $project: {
                localities: { $slice: ['$localities', 5] },
              },
            },
          ],
        },
      },
    ];

    const [result] = await this.clientModel.aggregate(pipeline).exec();
    const totals = result?.totals?.[0] ?? { total: 0, reconsultas: 0 };
    const total = totals.total ?? 0;
    const totalReconsultas = totals.reconsultas ?? 0;

    const noLocation = result?.noLocation?.[0] ?? { total: 0, reconsultas: 0 };
    const noLocationTotal = noLocation.total ?? 0;

    const countriesRaw = result?.countries ?? [];
    const provincesRaw = result?.provinces ?? [];
    const localitiesRaw = result?.localities ?? [];
    const topProductProvinceRaw = result?.topProductProvince ?? [];
    const topProductLocalityRaw = result?.topProductLocality ?? [];
    const topLocalitiesByProvinceRaw = result?.topLocalitiesByProvince ?? [];

    const countryMap = new Map<string, LocationReport['countries'][number]>();

    const normalizedCountryName = (value?: string | null) =>
      value && value.trim().length > 0 ? value.trim() : 'País no informado';
    const normalizedProvinceName = (value?: string | null) =>
      value && value.trim().length > 0 ? value.trim() : null;
    const normalizedLocalityName = (value?: string | null) =>
      value && value.trim().length > 0 ? value.trim() : null;

    countriesRaw.forEach((country: any) => {
      const name = normalizedCountryName(country._id);
      countryMap.set(name, {
        name,
        total: country.total ?? 0,
        percentage: total > 0 ? Math.round((country.total / total) * 100) : 0,
        provinces: [],
      });
    });

    const provinceMap = new Map<string, LocationReport['countries'][number]['provinces'][number]>();
    provincesRaw.forEach((province: any) => {
      const countryName = normalizedCountryName(province._id?.country);
      const provinceName = normalizedProvinceName(province._id?.province);
      if (!provinceName) {
        return;
      }
      const key = `${countryName}::${provinceName}`;
      const provinceData = {
        name: provinceName,
        total: province.total ?? 0,
        percentage: total > 0 ? Math.round((province.total / total) * 100) : 0,
        reconsultas: province.reconsultas ?? 0,
        topProduct: undefined,
        topLocalities: [],
        localities: [],
      };
      provinceMap.set(key, provinceData);

      const countryEntry =
        countryMap.get(countryName) ??
        {
          name: countryName,
          total: 0,
          percentage: 0,
          provinces: [],
        };
      if (!countryMap.has(countryName)) {
        countryMap.set(countryName, countryEntry);
      }
      countryEntry.provinces.push(provinceData);
    });

    const localityMap = new Map<string, LocationReport['countries'][number]['provinces'][number]['localities'][number]>();
    localitiesRaw.forEach((locality: any) => {
      const countryName = normalizedCountryName(locality._id?.country);
      const provinceName = normalizedProvinceName(locality._id?.province);
      const localityName = normalizedLocalityName(locality._id?.locality);
      if (!provinceName || !localityName) {
        return;
      }
      const key = `${countryName}::${provinceName}::${localityName}`;
      const localityData = {
        name: localityName,
        total: locality.total ?? 0,
        percentage: total > 0 ? Math.round((locality.total / total) * 100) : 0,
        reconsultas: locality.reconsultas ?? 0,
        topProduct: undefined,
      };
      localityMap.set(key, localityData);
      const provinceKey = `${countryName}::${provinceName}`;
      const provinceEntry = provinceMap.get(provinceKey);
      if (provinceEntry) {
        provinceEntry.localities.push(localityData);
      }
    });

    topProductProvinceRaw.forEach((entry: any) => {
      const countryName = normalizedCountryName(entry._id?.country);
      const provinceName = normalizedProvinceName(entry._id?.province);
      if (!provinceName) {
        return;
      }
      const provinceKey = `${countryName}::${provinceName}`;
      const provinceEntry = provinceMap.get(provinceKey);
      if (!provinceEntry) {
        return;
      }
      provinceEntry.topProduct = {
        name: entry.product ?? 'Sin dato',
        total: entry.total ?? 0,
        percentage:
          provinceEntry.total > 0 ? Math.round((entry.total / provinceEntry.total) * 100) : 0,
      };
    });

    topProductLocalityRaw.forEach((entry: any) => {
      const countryName = normalizedCountryName(entry._id?.country);
      const provinceName = normalizedProvinceName(entry._id?.province);
      const localityName = normalizedLocalityName(entry._id?.locality);
      if (!provinceName || !localityName) {
        return;
      }
      const localityKey = `${countryName}::${provinceName}::${localityName}`;
      const localityEntry = localityMap.get(localityKey);
      if (!localityEntry) {
        return;
      }
      localityEntry.topProduct = {
        name: entry.product ?? 'Sin dato',
        total: entry.total ?? 0,
        percentage:
          localityEntry.total > 0 ? Math.round((entry.total / localityEntry.total) * 100) : 0,
      };
    });

    topLocalitiesByProvinceRaw.forEach((entry: any) => {
      const countryName = normalizedCountryName(entry._id?.country);
      const provinceName = normalizedProvinceName(entry._id?.province);
      if (!provinceName) {
        return;
      }
      const provinceKey = `${countryName}::${provinceName}`;
      const provinceEntry = provinceMap.get(provinceKey);
      if (!provinceEntry) {
        return;
      }
      provinceEntry.topLocalities = (entry.localities ?? [])
        .map((loc: any) => ({
          name: normalizedLocalityName(loc.name),
          total: loc.total ?? 0,
          percentage:
            provinceEntry.total > 0
              ? Math.round((loc.total / provinceEntry.total) * 100)
              : 0,
        }))
        .filter((loc: any) => loc.name);
    });

    const countries = Array.from(countryMap.values())
      .sort((a, b) => b.total - a.total)
      .sort((a, b) => (a.name === 'País no informado' ? 1 : -1));
    countries.forEach((country) => {
      country.provinces.sort((a, b) => b.total - a.total);
      country.provinces.forEach((province) => {
        province.localities.sort((a, b) => b.total - a.total);
        province.localities.forEach((locality) => {
          locality.percentage =
            province.total > 0 ? Math.round((locality.total / province.total) * 100) : 0;
        });
      });
    });

    return {
      total,
      totalReconsultas,
      noLocation: {
        total: noLocationTotal,
        percentage: total > 0 ? Math.round((noLocationTotal / total) * 100) : 0,
        reconsultas: noLocation.reconsultas ?? 0,
      },
      countries,
    };
  }

  private async getMapPoints(
    report: LocationReport,
    filters: LocationFilters,
  ): Promise<LocationSummary['mapPoints']> {
    const matchDate: Record<string, any> = {};
    if (filters.startDate || filters.endDate) {
      matchDate.createdAt = {};
      if (filters.startDate) {
        matchDate.createdAt.$gte = new Date(filters.startDate);
      }
      if (filters.endDate) {
        matchDate.createdAt.$lte = new Date(filters.endDate);
      }
    }

    const matchResolved: Record<string, any> = {};
    if (filters.provincias && filters.provincias.length > 0) {
      matchResolved['ubicacion.provincia'] = { $in: filters.provincias };
    }
    if (filters.paises && filters.paises.length > 0) {
      matchResolved['ubicacion.pais'] = { $in: filters.paises };
    }
    if (filters.zonas && filters.zonas.length > 0) {
      matchResolved['ubicacion.zona'] = { $in: filters.zonas };
    }

    const pipeline: mongoose.PipelineStage[] = [
      Object.keys(matchDate).length > 0 ? { $match: matchDate } : { $match: {} },
      Object.keys(matchResolved).length > 0 ? { $match: matchResolved } : { $match: {} },
      {
        $match: {
          'ubicacion.lat': { $ne: null },
          'ubicacion.lon': { $ne: null },
        },
      },
      {
        $group: {
          _id: {
            name: { $ifNull: ['$ubicacion.localidad', '$ubicacion.provincia'] },
            lat: '$ubicacion.lat',
            lon: '$ubicacion.lon',
          },
          total: { $sum: 1 },
        },
      },
      { $sort: { total: -1 } },
      { $limit: 10 },
      {
        $project: {
          _id: 0,
          name: '$_id.name',
          lat: '$_id.lat',
          lon: '$_id.lon',
          total: 1,
        },
      },
    ];

    const storedPoints = await this.clientModel.aggregate(pipeline).exec();
    if (storedPoints.length > 0) {
      return storedPoints;
    }

    const provinceFallback = this.buildProvinceFallbackMapPoints(report);
    if (provinceFallback.length > 0) {
      await this.persistProvinceFallbackPoints(provinceFallback);
      return provinceFallback;
    }

    return [];
  }

  private buildProvinceFallbackMapPoints(
    report: LocationReport,
  ): LocationSummary['mapPoints'] {
    const centroids: Record<string, { lat: number; lon: number }> = {
      'buenos aires': { lat: -36.6769, lon: -60.5588 },
      'catamarca': { lat: -28.4696, lon: -65.7795 },
      'chaco': { lat: -26.3864, lon: -60.7658 },
      'chubut': { lat: -43.2934, lon: -65.1115 },
      'cordoba': { lat: -31.4201, lon: -64.1888 },
      'corrientes': { lat: -27.4692, lon: -58.8306 },
      'entre rios': { lat: -31.7431, lon: -60.5171 },
      'formosa': { lat: -26.1775, lon: -58.1781 },
      'jujuy': { lat: -24.1858, lon: -65.2995 },
      'la pampa': { lat: -37.1315, lon: -64.5943 },
      'la rioja': { lat: -29.4131, lon: -66.8568 },
      'mendoza': { lat: -32.8908, lon: -68.8272 },
      'misiones': { lat: -27.3671, lon: -55.8961 },
      'neuquen': { lat: -38.9516, lon: -68.0591 },
      'rio negro': { lat: -40.8261, lon: -63.0266 },
      'salta': { lat: -24.7821, lon: -65.4232 },
      'san juan': { lat: -31.5375, lon: -68.5364 },
      'san luis': { lat: -33.3017, lon: -66.3378 },
      'santa cruz': { lat: -51.6333, lon: -69.2167 },
      'santa fe': { lat: -31.6333, lon: -60.7000 },
      'santiago del estero': { lat: -27.7844, lon: -64.2673 },
      'tierra del fuego': { lat: -54.8019, lon: -68.3030 },
      'tucuman': { lat: -26.8083, lon: -65.2176 },
      'caba': { lat: -34.6037, lon: -58.3816 },
      'ciudad autonoma de buenos aires': { lat: -34.6037, lon: -58.3816 },
    };

    const provinces = report.countries
      .flatMap((country) => country.provinces)
      .sort((a, b) => b.total - a.total)
      .slice(0, 8);

    return provinces
      .map((province) => {
        const key = this.normalizeProvinceKey(province.name);
        const coords = centroids[key];
        if (!coords) {
          return null;
        }
        return {
          name: province.name,
          lat: coords.lat,
          lon: coords.lon,
          total: province.total,
        };
      })
      .filter((item): item is LocationSummary['mapPoints'][number] => !!item);
  }

  private normalizeProvinceKey(value: string): string {
    return value
      .toLowerCase()
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '')
      .replace(/\bprovincia\s+de\s+/g, '')
      .replace(/\bprovincia\s+/g, '')
      .replace(/\bprov\.?\s+/g, '')
      .replace(/\s+/g, ' ')
      .trim();
  }

  private async persistProvinceFallbackPoints(
    points: LocationSummary['mapPoints'],
  ): Promise<void> {
    await Promise.all(
      points.map(async (point) => {
        const regex = this.buildDiacriticRegex(point.name, false);
        await this.clientModel.updateMany(
          {
            $and: [
              {
                $or: [
                  { 'ubicacion.provincia': { $regex: regex } },
                  { provincia: { $regex: regex } },
                ],
              },
              {
                $or: [
                  { 'ubicacion.lat': { $exists: false } },
                  { 'ubicacion.lat': null },
                ],
              },
            ],
          },
          {
            $set: {
              'ubicacion.lat': point.lat,
              'ubicacion.lon': point.lon,
              'ubicacion.fuente': 'PROVINCIA_CENTRO',
              'ubicacion.esNormalizada': false,
            },
          },
        );
      }),
    );
  }

  private buildDiacriticRegex(value: string, strict: boolean = true): RegExp {
    const escape = (text: string) => text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const map: Record<string, string> = {
      a: '[aáàäâã]',
      e: '[eéèëê]',
      i: '[iíìïî]',
      o: '[oóòöôõ]',
      u: '[uúùüû]',
      n: '[nñ]',
      c: '[cç]',
    };
    const pattern = escape(value)
      .split('')
      .map((char) => {
        const lower = char.toLowerCase();
        return map[lower] ?? escape(char);
      })
      .join('');
    return strict ? new RegExp(`^\\s*${pattern}\\s*$`, 'i') : new RegExp(pattern, 'i');
  }

  private async findClientsForReport(filters: LocationFilters): Promise<Client[]> {
    const query: Record<string, any> = {};
    if (filters.startDate || filters.endDate) {
      query.createdAt = {};
      if (filters.startDate) {
        query.createdAt.$gte = new Date(filters.startDate);
      }
      if (filters.endDate) {
        query.createdAt.$lte = new Date(filters.endDate);
      }
    }
    if (filters.provincias && filters.provincias.length > 0) {
      query['ubicacion.esNormalizada'] = true;
      query['ubicacion.provincia'] = { $in: filters.provincias };
    }
    if (filters.paises && filters.paises.length > 0) {
      query['ubicacion.esNormalizada'] = true;
      query['ubicacion.pais'] = { $in: filters.paises };
    }
    if (filters.zonas && filters.zonas.length > 0) {
      query['ubicacion.esNormalizada'] = true;
      query['ubicacion.zona'] = { $in: filters.zonas };
    }
    return this.clientModel.find(query).lean();
  }

  private async generateLocationPdf(
    report: LocationReport,
    clients: Client[],
    filters: LocationFilters,
  ): Promise<Buffer> {
    const doc = new PDFDocument({ margin: 36, size: 'A4', layout: 'landscape' });
    const chunks: Buffer[] = [];
    doc.on('data', (chunk) => chunks.push(Buffer.from(chunk)));

    const title = 'Reporte de Clientes por Ubicación';
    this.drawSectionHeader(doc, title);
    doc.fontSize(10).fillColor('#6B7280').text('Generado: ' + new Date().toLocaleString('es-AR'));
    doc.moveDown(0.4);

    const filtersLabel = [
      filters.startDate ? `Desde: ${filters.startDate}` : null,
      filters.endDate ? `Hasta: ${filters.endDate}` : null,
      filters.provincias && filters.provincias.length > 0
        ? `Provincias: ${filters.provincias.join(', ')}`
        : null,
      filters.paises && filters.paises.length > 0 ? `Países: ${filters.paises.join(', ')}` : null,
      filters.zonas && filters.zonas.length > 0 ? `Zonas: ${filters.zonas.join(', ')}` : null,
    ]
      .filter(Boolean)
      .join(' | ');

    if (filtersLabel) {
      doc.fontSize(10).fillColor('#374151').text(filtersLabel);
      doc.moveDown(0.4);
    }

    const summaryRows = [
      ['Total de consultas', String(report.total)],
      ['Reconsultas', String(report.totalReconsultas)],
      [
        'Sin datos de ubicación',
        `${report.noLocation.total} (${report.noLocation.percentage}%)`,
      ],
    ];
    this.drawSimpleTable(doc, 'Resumen general', ['Métrica', 'Valor'], summaryRows, [0.55, 0.45]);

    const topProvinceMap = new Map<
      string,
      { name: string; total: number; percentage: number }
    >();
    report.countries.forEach((country) => {
      country.provinces.forEach((province) => {
        const normalized = this.normalizeProvinceKey(province.name);
        if (!normalized || normalized.startsWith('sin ')) {
          return;
        }
        const existing = topProvinceMap.get(normalized);
        if (existing) {
          existing.total += province.total;
          existing.percentage =
            report.total > 0 ? Math.round((existing.total / report.total) * 100) : 0;
          if (province.name.length > existing.name.length) {
            existing.name = province.name;
          }
        } else {
          topProvinceMap.set(normalized, {
            name: province.name,
            total: province.total,
            percentage: report.total > 0 ? Math.round((province.total / report.total) * 100) : 0,
          });
        }
      });
    });

    const topProvinces = Array.from(topProvinceMap.values())
      .sort((a, b) => b.total - a.total)
      .slice(0, 6);

    if (topProvinces.length > 0) {
      const rows = topProvinces.map((item) => [
        item.name,
        String(item.total),
        `${item.percentage}%`,
      ]);
      this.drawSimpleTable(
        doc,
        'Top provincias por consultas',
        ['Provincia', 'Consultas', '% del total'],
        rows,
        [0.6, 0.2, 0.2],
      );
    }

    const topProducts = report.countries
      .flatMap((country) =>
        country.provinces
          .map((province) => province.topProduct)
          .filter(
            (product): product is NonNullable<
              LocationReport['countries'][number]['provinces'][number]['topProduct']
            > => !!product,
          ),
      )
      .reduce<Record<string, number>>((acc, product) => {
        acc[product.name] = (acc[product.name] ?? 0) + product.total;
        return acc;
      }, {});
    const topProductsData = Object.entries(topProducts)
      .map(([name, total]) => ({
        name,
        total,
        percentage: report.total > 0 ? Math.round((total / report.total) * 100) : 0,
      }))
      .sort((a, b) => b.total - a.total)
      .slice(0, 6);
    if (topProductsData.length > 0) {
      const rows = topProductsData.map((item) => [
        item.name,
        String(item.total),
        `${item.percentage}%`,
      ]);
      this.drawSimpleTable(
        doc,
        'Productos más pedidos (global)',
        ['Producto', 'Consultas', '% del total'],
        rows,
        [0.65, 0.2, 0.15],
      );
    }

    const provinces = report.countries.flatMap((country) => country.provinces);

    provinces.forEach((province) => {
      doc.addPage();
      this.drawSectionHeader(doc, `Provincia: ${province.name}`);
      const provinceRows = [
        ['Consultas', `${province.total} (${province.percentage}%)`],
        ['Reconsultas', String(province.reconsultas)],
        [
          'Producto más pedido',
          province.topProduct
            ? `${province.topProduct.name} (${province.topProduct.total} | ${province.topProduct.percentage}%)`
            : 'Sin dato',
        ],
      ];
      this.drawSimpleTable(
        doc,
        'Resumen de provincia',
        ['Métrica', 'Valor'],
        provinceRows,
        [0.35, 0.65],
      );
      if (province.topLocalities.length > 0) {
        this.drawLocalityTable(doc, 'Localidades con más consultas', province.topLocalities);
      }
      doc.moveDown(0.4);

      this.renderClientTable(
        doc,
        clients.filter((client) => this.matchesProvince(client, province.name)),
      );
      doc.moveDown(0.8);
    });

    if (report.noLocation.total > 0) {
      doc.addPage();
      this.drawSectionHeader(doc, 'Sin datos de ubicación del cliente');
      doc.moveDown(0.4);
      this.renderClientTable(doc, clients.filter((client) => !this.hasLocation(client)));
    }

    doc.end();

    return new Promise((resolve) => {
      doc.on('end', () => {
        resolve(Buffer.concat(chunks as Uint8Array[]));
      });
    });
  }

  private drawBarChart(
    doc: PDFKit.PDFDocument,
    title: string,
    data: Array<{ name: string; total: number }>,
  ) {
    if (data.length === 0) {
      return;
    }
    const startX = doc.page.margins.left;
    const chartWidth = doc.page.width - doc.page.margins.left - doc.page.margins.right;
    const barHeight = 10;
    const gap = 5;
    const maxValue = Math.max(...data.map((item) => item.total), 1);
    doc.fontSize(10).fillColor('#111827').text(title, startX, doc.y);
    doc.moveDown(0.3);

    data.forEach((item) => {
      this.ensurePageSpace(doc, 24);
      const barWidth = (item.total / maxValue) * (chartWidth - 180);
      const barStartX = startX + 140;
      const startY = doc.y + 1;
      doc
        .fillColor('#111827')
        .fontSize(8)
        .text(item.name, startX, doc.y, { width: 130, ellipsis: true });
      doc.rect(barStartX, startY, barWidth, barHeight).fill('#FBBF24');
      doc
        .fillColor('#111827')
        .fontSize(8)
        .text(String(item.total), barStartX + barWidth + 6, doc.y, { width: 30 });
      doc.moveDown(0.6);
      doc.y += gap;
    });
  }

  private drawLocalityTable(
    doc: PDFKit.PDFDocument,
    title: string,
    rows: Array<{ name: string; total: number; percentage: number }>,
  ) {
    if (rows.length === 0) {
      return;
    }
    const tableWidth =
      doc.page.width - doc.page.margins.left - doc.page.margins.right;
    this.drawSubheading(doc, title);
    doc.moveDown(0.2);

    const headers = ['Localidad', 'Consultas', '% del total'];
    const colWidths = [tableWidth * 0.6, tableWidth * 0.2, tableWidth * 0.2];
    this.drawTableHeader(doc, headers, colWidths, tableWidth);
    rows.forEach((row, index) => {
      const cells = [row.name, String(row.total), `${row.percentage}%`];
      this.drawTableRow(doc, cells, colWidths, tableWidth, index % 2 === 0);
    });
    doc.moveDown(0.6);
  }

  private drawSimpleTable(
    doc: PDFKit.PDFDocument,
    title: string,
    headers: string[],
    rows: string[][],
    widthRatios: number[],
  ) {
    if (rows.length === 0) {
      return;
    }
    const tableWidth =
      doc.page.width - doc.page.margins.left - doc.page.margins.right;
    this.drawSubheading(doc, title);
    doc.moveDown(0.2);
    const colWidths = this.getTableWidthsByRatios(tableWidth, widthRatios);
    this.drawTableHeader(doc, headers, colWidths, tableWidth);
    rows.forEach((row, index) => {
      this.drawTableRow(doc, row, colWidths, tableWidth, index % 2 === 0);
    });
    doc.moveDown(0.8);
  }

  private getTableWidthsByRatios(tableWidth: number, ratios: number[]) {
    const total = ratios.reduce((sum, value) => sum + value, 0);
    return ratios.map((value) => Math.floor((value / total) * tableWidth));
  }

  private renderClientTable(doc: PDFKit.PDFDocument, clients: Client[]) {
    if (clients.length === 0) {
      return;
    }

    const tableWidth =
      doc.page.width - doc.page.margins.left - doc.page.margins.right;
    const colWidths = this.getClientTableWidths(tableWidth);
    const headers = [
      'Cliente',
      'Telefono',
      'Email',
      'Producto',
      'Ubicacion',
      'Estado',
      'Seguimiento',
      'Reconsulta',
      'Creado',
    ];

    this.drawTableHeader(doc, headers, colWidths, tableWidth);
    clients.forEach((client, index) => {
      const row = this.buildClientRow(client);
      this.drawTableRow(doc, row, colWidths, tableWidth, index % 2 === 0);
      this.drawClientDetailRow(doc, client, tableWidth);
    });
  }

  private drawTableHeader(
    doc: PDFKit.PDFDocument,
    headers: string[],
    colWidths: number[],
    tableWidth: number,
  ) {
    this.ensurePageSpace(doc, 28);
    const startX = doc.page.margins.left;
    const startY = doc.y;
    doc.fillColor('#0F172A').rect(startX, startY, tableWidth, 20).fill();
    doc.fillColor('#FFFFFF').fontSize(8);
    let x = startX;
    headers.forEach((header, idx) => {
      doc.text(header, x + 4, startY + 5, { width: colWidths[idx] - 8 });
      x += colWidths[idx];
    });
    doc.moveDown(1.1);
  }

  private drawTableRow(
    doc: PDFKit.PDFDocument,
    row: string[],
    colWidths: number[],
    tableWidth: number,
    shaded: boolean,
  ) {
    const startX = doc.page.margins.left;
    const paddingY = 3;
    const paddingX = 3;
    const rowHeights = row.map((cell, idx) =>
      doc.heightOfString(cell, { width: colWidths[idx] - paddingX * 2 }),
    );
    const rowHeight = Math.max(...rowHeights, 10) + paddingY * 2;
    this.ensurePageSpace(doc, rowHeight + 6);
    const startY = doc.y;
    if (shaded) {
      doc.fillColor('#F8FAFC').rect(startX, startY, tableWidth, rowHeight).fill();
    }
    let x = startX;
    doc.fontSize(7).fillColor('#111827');
    row.forEach((cell, idx) => {
      doc.text(cell, x + paddingX, startY + paddingY, {
        width: colWidths[idx] - paddingX * 2,
      });
      x += colWidths[idx];
    });
    doc
      .moveTo(startX, startY + rowHeight)
      .lineTo(startX + tableWidth, startY + rowHeight)
      .strokeColor('#E2E8F0')
      .stroke();
    doc.moveDown(0.6);
  }

  private buildClientRow(client: Client): string[] {
    const ubicacion = client.ubicacion ?? {};
    return [
      [client.nombre, client.apellido].filter(Boolean).join(' ') || 'Sin nombre',
      client.telefono ?? '',
      client.correo ?? '',
      client.producto ?? '',
      this.buildLocationLabel(ubicacion, client),
      client.estado ?? '',
      client.siguiendo ?? '',
      client.isReconsulta ? 'Si' : 'No',
      client.createdAt ? new Date(client.createdAt).toLocaleDateString('es-AR') : '',
    ];
  }

  private getClientHeader(client: Client): string {
    const nameParts = [client.nombre, client.apellido].filter(Boolean).join(' ');
    const phone = client.telefono ? ` | ${client.telefono}` : '';
    return `${nameParts || 'Cliente sin nombre'}${phone}`;
  }

  private getClientDetails(client: Client): string[] {
    const ubicacion = client.ubicacion ?? {};
    const details: Array<[string, string | undefined]> = [
      ['Correo', client.correo],
      ['Producto', client.producto],
      ['Actividad', client.actividad],
      ['Estado', client.estado],
      ['Siguiendo', client.siguiendo],
      ['Provincia', ubicacion.provincia ?? client.provincia],
      ['Localidad', ubicacion.localidad ?? client.localidad],
      ['País', ubicacion.pais],
      ['Zona', ubicacion.zona],
      ['Cabezas', client.cabezas],
      ['Meses', client.mesesSuplemento],
      ['Medio', client.medioAdquisicion],
      ['Reconsulta', client.isReconsulta ? 'Sí' : 'No'],
      ['Creado', client.createdAt ? new Date(client.createdAt).toLocaleDateString('es-AR') : undefined],
      ['Observaciones', client.observaciones],
    ];

    return details
      .filter(([, value]) => value !== undefined && value !== null && String(value).trim().length > 0)
      .map(([label, value]) => `${label}: ${value}`);
  }

  private matchesProvince(client: Client, province: string): boolean {
    const ubicacion = client.ubicacion ?? {};
    if (!ubicacion.esNormalizada || !ubicacion.provincia) {
      return false;
    }
    return (
      this.normalizeProvinceKey(ubicacion.provincia) === this.normalizeProvinceKey(province)
    );
  }

  private hasLocation(client: Client): boolean {
    const ubicacion = client.ubicacion ?? {};
    if (!ubicacion.esNormalizada) {
      return false;
    }
    const values = [ubicacion.provincia, ubicacion.localidad, ubicacion.zona];
    return values.some((value) => this.isValidLocationValue(value));
  }

  private ensurePageSpace(doc: PDFKit.PDFDocument, space: number) {
    const bottom = doc.page.height - doc.page.margins.bottom;
    if (doc.y + space >= bottom) {
      doc.addPage();
    }
  }

  private getClientTableWidths(tableWidth: number): number[] {
    const raw = [1.6, 1, 1.5, 1.3, 2.2, 1, 1.1, 0.9, 1];
    const total = raw.reduce((a, b) => a + b, 0);
    return raw.map((value) => Math.floor((value / total) * tableWidth));
  }

  private drawClientDetailRow(doc: PDFKit.PDFDocument, client: Client, tableWidth: number) {
    const line = this.buildClientDetailLine(client);
    const paddingY = 3;
    const height =
      doc.heightOfString(line, { width: tableWidth - 10 }) + paddingY * 2;
    this.ensurePageSpace(doc, height + 4);
    const startX = doc.page.margins.left;
    const startY = doc.y;
    doc.fillColor('#FFFFFF').rect(startX, startY, tableWidth, height).fill();
    doc.fontSize(7).fillColor('#6B7280').text(line, startX + 5, startY + paddingY, {
      width: tableWidth - 10,
    });
    doc.moveDown(0.6);
  }

  private buildClientDetailLine(client: Client): string {
    const parts: string[] = [];
    if (client.actividad) parts.push(`Actividad: ${client.actividad}`);
    if (client.medioAdquisicion) parts.push(`Medio: ${client.medioAdquisicion}`);
    if (client.cabezas) parts.push(`Cabezas: ${client.cabezas}`);
    if (client.mesesSuplemento) parts.push(`Meses: ${client.mesesSuplemento}`);
    if (client.observaciones) parts.push(`Obs: ${client.observaciones}`);
    return parts.length > 0
      ? parts.join(' | ')
      : 'Sin datos adicionales para este cliente.';
  }

  private buildLocationLabel(
    ubicacion: Client['ubicacion'] | undefined,
    client: Client,
  ): string {
    const parts = [
      ubicacion?.localidad ?? client.localidad,
      ubicacion?.provincia ?? client.provincia,
      ubicacion?.pais,
    ].filter((value) => this.isValidLocationValue(value));
    return parts.length > 0 ? parts.join(', ') : 'Sin datos';
  }

  private drawSectionHeader(doc: PDFKit.PDFDocument, text: string) {
    const startX = doc.page.margins.left;
    const width = doc.page.width - doc.page.margins.left - doc.page.margins.right;
    const y = doc.y;
    doc.fillColor('#0F172A').rect(startX, y, width, 26).fill();
    doc.fillColor('#FBBF24').rect(startX, y, 6, 26).fill();
    doc.fillColor('#FFFFFF').fontSize(14).text(text, startX + 14, y + 7);
    doc.moveDown(1.7);
  }

  private drawSubheading(doc: PDFKit.PDFDocument, text: string) {
    const startX = doc.page.margins.left;
    doc.fillColor('#0F172A').fontSize(11).text(text, startX, doc.y);
    doc.moveDown(0.2);
  }

  private isValidLocationValue(value: unknown): boolean {
    if (!value) {
      return false;
    }
    const stringValue = String(value).trim();
    if (!stringValue) {
      return false;
    }
    const lower = stringValue.toLowerCase();
    const invalidValues = [
      '-',
      'null',
      'undefined',
      'sin datos',
      'sin informacion',
      'sin información',
      'no disponible',
      'n/a',
      'na',
      'sin localidad',
      'sin provincia',
      'sin pais',
      'sin país',
    ];
    if (invalidValues.includes(lower)) {
      return false;
    }
    if (lower.includes('{{') || lower.includes('}}') || lower.includes('cuf_')) {
      return false;
    }
    return true;
  }

  private async ensureNormalizedLocations(filters: LocationFilters): Promise<void> {
    const retryAfter = new Date(Date.now() - this.geoFailureTtlMs);
    const query: Record<string, any> = {
      $and: [
        {
          $or: [
            { 'ubicacion.esNormalizada': { $ne: true } },
            { ubicacion: { $exists: false } },
          ],
        },
        {
          $or: [
            { localidad: { $exists: true, $ne: null } },
            { provincia: { $exists: true, $ne: null } },
            { 'ubicacion.localidad': { $exists: true, $ne: null } },
            { 'ubicacion.provincia': { $exists: true, $ne: null } },
            { 'ubicacion.zona': { $exists: true, $ne: null } },
          ],
        },
        {
          $or: [
            { 'ubicacion.normalizacionFallidaAt': { $exists: false } },
            { 'ubicacion.normalizacionFallidaAt': { $lte: retryAfter } },
          ],
        },
      ],
    };

    if (filters.startDate || filters.endDate) {
      query.createdAt = {};
      if (filters.startDate) {
        query.createdAt.$gte = new Date(filters.startDate);
      }
      if (filters.endDate) {
        query.createdAt.$lte = new Date(filters.endDate);
      }
    }

    for (let batchIndex = 0; batchIndex < this.normalizationMaxBatches; batchIndex += 1) {
      const candidates = await this.clientModel
        .find(query)
        .select({
          provincia: 1,
          localidad: 1,
          ubicacion: 1,
        })
        .limit(this.normalizationBatchSize)
        .lean();

      if (candidates.length === 0) {
        return;
      }

      for (let i = 0; i < candidates.length; i += this.normalizationConcurrency) {
        const batch = candidates.slice(i, i + this.normalizationConcurrency);
        await Promise.all(batch.map((client) => this.normalizeClientLocation(client)));
      }
    }
  }

  private async normalizeClientLocation(client: Partial<Client> & { _id?: any }): Promise<void> {
    const rawParts = this.extractLocationParts(client);
    if (!rawParts) {
      return;
    }
    const query = rawParts.query;
    if (query.length < 3) {
      return;
    }
    const cachedFailAt = this.geoFailureCache.get(query);
    if (cachedFailAt && Date.now() - cachedFailAt < this.geoFailureTtlMs) {
      return;
    }

    try {
      const results = await this.geoService.search(query, 1);
      const best = results[0];
      if (!best) {
        this.geoFailureCache.set(query, Date.now());
        await this.clientModel.updateOne(
          { _id: client._id },
          {
            $set: {
              'ubicacion.fuente': 'NO_MATCH',
              'ubicacion.esNormalizada': false,
              'ubicacion.normalizacionFallidaAt': new Date(),
            },
          },
        );
        return;
      }

      await this.clientModel.updateOne(
        { _id: client._id },
        {
          $set: {
            'ubicacion.pais': 'Argentina',
            'ubicacion.provincia': best.provincia,
            'ubicacion.localidad': best.localidad,
            'ubicacion.zona': best.zona,
            'ubicacion.lat': best.lat,
            'ubicacion.lon': best.lon,
            'ubicacion.displayName': best.displayName ?? best.label,
            'ubicacion.fuente': best.fuente ?? 'NOMINATIM',
            'ubicacion.esNormalizada': true,
          },
          $unset: {
            'ubicacion.normalizacionFallidaAt': '',
          },
        },
      );
    } catch (error) {
      this.geoFailureCache.set(query, Date.now());
      await this.clientModel.updateOne(
        { _id: client._id },
        {
          $set: {
            'ubicacion.fuente': 'ERROR',
            'ubicacion.esNormalizada': false,
            'ubicacion.normalizacionFallidaAt': new Date(),
          },
        },
      );
    }
  }

  private extractLocationParts(
    client: Partial<Client>,
  ): { query: string } | null {
    const ubicacion = client.ubicacion ?? {};
    const rawLocality = this.pickFirstValid([
      ubicacion.localidad,
      client.localidad,
    ]);
    const rawProvince = this.pickFirstValid([
      ubicacion.provincia,
      client.provincia,
    ]);
    const rawZone = this.pickFirstValid([ubicacion.zona]);

    const combined = [rawLocality, rawProvince, rawZone]
      .filter((value) => this.isValidLocationValue(value))
      .join(' ')
      .trim();
    if (!combined) {
      return null;
    }

    let locality = rawLocality ?? undefined;
    let province = rawProvince ?? undefined;

    const parsedFromLocality = rawLocality
      ? this.splitLocationTokens(rawLocality)
      : null;
    if (parsedFromLocality?.province && !province) {
      province = parsedFromLocality.province;
    }
    if (parsedFromLocality?.locality) {
      locality = parsedFromLocality.locality;
    }

    const parsedFromProvince = rawProvince
      ? this.splitLocationTokens(rawProvince)
      : null;
    if (!province && parsedFromProvince?.province) {
      province = parsedFromProvince.province;
    }
    if (!locality && parsedFromProvince?.locality) {
      locality = parsedFromProvince.locality;
    }

    province = province ? this.normalizeProvinceAlias(province) : undefined;

    const queryParts = [
      locality,
      province,
      rawZone && !province ? rawZone : undefined,
      'Argentina',
    ].filter((value) => this.isValidLocationValue(value));

    if (queryParts.length === 0) {
      return null;
    }

    return { query: queryParts.join(', ') };
  }

  private splitLocationTokens(
    value: string,
  ): { locality?: string; province?: string } | null {
    if (!value) {
      return null;
    }
    const cleaned = value.replace(/\s+/g, ' ').trim();
    if (!cleaned) {
      return null;
    }
    if (cleaned.includes(',')) {
      const [left, right] = cleaned.split(',').map((part) => part.trim());
      const province = right ? this.normalizeProvinceAlias(right) : undefined;
      return {
        locality: left || undefined,
        province,
      };
    }

    const alias = this.normalizeProvinceAlias(cleaned);
    if (alias && alias !== cleaned) {
      const locality = cleaned
        .replace(new RegExp(alias, 'i'), '')
        .replace(/\b(bsas|buenos aires|caba|cba|mza|sf|sta fe|er)\b/gi, '')
        .replace(/\s+/g, ' ')
        .trim();
      return {
        locality: locality || undefined,
        province: alias,
      };
    }

    return { province: alias || cleaned };
  }

  private normalizeProvinceAlias(value: string): string {
    const lower = value.toLowerCase();
    const normalized = lower
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '')
      .replace(/\./g, '')
      .trim();

    const patterns: Array<[RegExp, string]> = [
      [/\b(bsas|buenos aires|b a|baires)\b/i, 'Buenos Aires'],
      [/\b(caba|ciudad autonoma)\b/i, 'Ciudad Autónoma de Buenos Aires'],
      [/\b(cba|cordoba)\b/i, 'Córdoba'],
      [/\b(sf|santa fe|sta fe)\b/i, 'Santa Fe'],
      [/\b(er|entre rios)\b/i, 'Entre Ríos'],
      [/\b(la pampa|lp)\b/i, 'La Pampa'],
      [/\b(mza|mendoza)\b/i, 'Mendoza'],
      [/\b(misiones)\b/i, 'Misiones'],
      [/\b(rio negro|rionegro)\b/i, 'Río Negro'],
      [/\b(tucuman|tuc)\b/i, 'Tucumán'],
      [/\b(san luis)\b/i, 'San Luis'],
      [/\b(san juan)\b/i, 'San Juan'],
      [/\b(chaco)\b/i, 'Chaco'],
      [/\b(chubut)\b/i, 'Chubut'],
      [/\b(corrientes)\b/i, 'Corrientes'],
      [/\b(formosa)\b/i, 'Formosa'],
      [/\b(jujuy)\b/i, 'Jujuy'],
      [/\b(la rioja)\b/i, 'La Rioja'],
      [/\b(neuquen)\b/i, 'Neuquén'],
      [/\b(salta)\b/i, 'Salta'],
      [/\b(santa cruz)\b/i, 'Santa Cruz'],
      [/\b(santiago del estero)\b/i, 'Santiago del Estero'],
      [/\b(tierra del fuego)\b/i, 'Tierra del Fuego'],
      [/\b(catamarca)\b/i, 'Catamarca'],
    ];

    for (const [regex, province] of patterns) {
      if (regex.test(normalized)) {
        return province;
      }
    }

    return value.trim();
  }

  private pickFirstValid(values: Array<string | undefined | null>): string | undefined {
    for (const value of values) {
      if (this.isValidLocationValue(value)) {
        return String(value).trim();
      }
    }
    return undefined;
  }

  private buildHeatmapProvinces(report: LocationReport): LocationHeatmap['provinces'] {
    const total = report.total;
    const provinceMap = new Map<
      string,
      { name: string; normalized: string; total: number; percentage: number }
    >();

    report.countries.forEach((country) => {
      country.provinces.forEach((province) => {
        const normalized = this.normalizeProvinceKey(province.name);
        if (!normalized || normalized.startsWith('sin ')) {
          return;
        }
        const current = provinceMap.get(normalized);
        if (current) {
          current.total += province.total;
          current.percentage = total > 0 ? Math.round((current.total / total) * 100) : 0;
          if (province.name.length > current.name.length) {
            current.name = province.name;
          }
        } else {
          provinceMap.set(normalized, {
            name: province.name,
            normalized,
            total: province.total,
            percentage: total > 0 ? Math.round((province.total / total) * 100) : 0,
          });
        }
      });
    });

    return Array.from(provinceMap.values()).sort((a, b) => b.total - a.total);
  }
}
